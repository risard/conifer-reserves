<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Grammar of JSON Queries</title><meta name="generator" content="DocBook XSL Stylesheets V1.74.3"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="id1165551"></a>Grammar of JSON Queries</h1></div><div><div class="author"><h3 class="author"><span class="firstname">Scott</span> <span class="surname">McKellar</span></h3></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#id1165745">Introduction</a></span></dt><dt><span class="sect1"><a href="#id1165792">Primitives</a></span></dt><dt><span class="sect1"><a href="#id1165795">Query</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id1165745"></a>Introduction</h2></div></div></div><p>
			The format of this grammar approximates Extended Backus-Naur notation.  However it
			is intended as input to human beings, not to parser generators such as Lex or
			Yacc.  Do not expect formal rigor.  Sometimes narrative text will explain things
			that are clumsy to express in formal notation.  More often, the text will restate
			or summarize the formal productions.
		</p><p>
			Conventions:
		</p><div class="orderedlist"><ol type="1"><li>
				The grammar is a series of productions.
			</li><li>
				A production consists of a name, followed by "::=", followed by a
				definition for the name.  The name identifies a grammatical construct that can
				appear on the right side of another production.
			</li><li>
				Literals (including punctuation) are enclosed in single quotes, or in double
				quotes if case is not significant.
			</li><li>
				A single quotation mark within a literal is escaped with a preceding backslash.
			</li><li>
				If a construct can be defined more than one way, then the alternatives may appear
				in separate productions; or, they may appear in the same production, separated by
				pipe symbols.  The choice between these representations is of only cosmetic
				significance.
			</li><li>
				A construct enclosed within square brackets is optional.
			</li><li>
				A construct enclosed within curly braces may be repeated zero or more times.
			</li><li>
				JSON allows arbitrary white space between tokens.  To avoid ugly clutter, this
				grammar ignores the optional white space.
			</li><li>
				In many cases a production defines a JSON object, i.e. a list of name-value pairs,
				separated by commas.  Since the order of these name/value pairs is not significant,
				the grammar will not try to show all the possible sequences.  In general it will
				present the required pairs first, if any, followed by any optional elements.
			</li></ol></div><p>
			Since both EBNF and JSON use curly braces and square brackets, pay close attention to
			whether these characters are in single quotes.  If they're in single quotes, they are
			literal elements of the JSON notation.  Otherwise they are elements of the EBNF notation.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id1165792"></a>Primitives</h2></div></div></div><p>
			We'll start by defining some primitives, to get them out of the way.  They're
			mostly just what you would expect.
		</p><table width="100%" cellpadding="5" bgcolor="#F5DCB3" border="1" class="productionset" summary="EBNF"><tr><td><table border="0" width="99%" cellpadding="0" bgcolor="#F5DCB3" class="productionset" summary="EBNF productions"><tr><td align="left" valign="top" width="3%">[1]</td><td align="right" valign="top" width="10%">
					string
				</td><td valign="top" width="5%" align="center"><code>::=</code></td><td valign="top" width="52%">
					'&#8221;' chars '&#8221;'
				</td><td align="left" valign="top" width="30%"> </td></tr><tr><td align="left" valign="top" width="3%">[2]</td><td align="right" valign="top" width="10%">
					chars
				</td><td valign="top" width="5%" align="center"><code>::=</code></td><td valign="top" width="52%">
					any valid sequence of UTF-8 characters, with certain special characters
					escaped according to JSON rules
				</td><td align="left" valign="top" width="30%"> </td></tr><tr><td align="left" valign="top" width="3%">[3]</td><td align="right" valign="top" width="10%">
					integer_literal
				</td><td valign="top" width="5%" align="center"><code>::=</code></td><td valign="top" width="52%">
					[ sign ] digit { digit }
				</td><td align="left" valign="top" width="30%"> </td></tr><tr><td align="left" valign="top" width="3%">[4]</td><td align="right" valign="top" width="10%">
					sign
				</td><td valign="top" width="5%" align="center"><code>::=</code></td><td valign="top" width="52%">
					'+' | '-'
				</td><td align="left" valign="top" width="30%"> </td></tr><tr><td align="left" valign="top" width="3%">[5]</td><td align="right" valign="top" width="10%">
					digit
				</td><td valign="top" width="5%" align="center"><code>::=</code></td><td valign="top" width="52%">
				</td><td align="left" valign="top" width="30%"> </td></tr><tr><td align="left" valign="top" width="3%">[6]</td><td align="right" valign="top" width="10%">
					integer_string
				</td><td valign="top" width="5%" align="center"><code>::=</code></td><td valign="top" width="52%">
					'&#8221;'  integer_literal  '&#8221;'
				</td><td align="left" valign="top" width="30%"> </td></tr><tr><td align="left" valign="top" width="3%">[7]</td><td align="right" valign="top" width="10%">
					integer
				</td><td valign="top" width="5%" align="center"><code>::=</code></td><td valign="top" width="52%">
					integer_literal  |  integer_string
				</td><td align="left" valign="top" width="30%"> </td></tr><tr><td align="left" valign="top" width="3%">[8]</td><td align="right" valign="top" width="10%">
					number
				</td><td valign="top" width="5%" align="center"><code>::=</code></td><td valign="top" width="52%">
					any valid character sequence that is numeric according to JSON rules
				</td><td align="left" valign="top" width="30%"> </td></tr></table></td></tr></table><p>
			When json_query requires an integral value, it will usually accept a quoted string and
			convert it to an integer by brute force &#8211; to zero if necessary.  Likewise it may
			truncate a floating point number to an integral value.  Scientific notation will be
			accepted but may not give the intended results.
		</p><table width="100%" cellpadding="5" bgcolor="#F5DCB3" border="1" class="productionset" summary="EBNF"><tr><td><table border="0" width="99%" cellpadding="0" bgcolor="#F5DCB3" class="productionset" summary="EBNF productions"><tr><td align="left" valign="top" width="3%">[9]</td><td align="right" valign="top" width="10%">
					boolean
				</td><td valign="top" width="5%" align="center"><code>::=</code></td><td valign="top" width="52%">
					'true'  |  'false'  |  string  |  number
				</td><td align="left" valign="top" width="30%"> </td></tr></table></td></tr></table><p>
			The preferred way to encode a boolean is with the JSON reserved word true or false,
			in lower case without quotation marks.  The string &#8220;<code class="literal">trueK</code>&#8221;, in
			upper, lower, or mixed case, is another way to encode true.  Any other string
			evaluates to false.
		</p><p>
			As an accommodation to perl, numbers may be used as booleans.  A numeric value of 1
			means true, and any other numeric value means false.
		</p><p>
			Any other valid JSON value, such as an array, will be accepted as a boolean but interpreted
			as false.
		</p><p>
			The last couple of primitives aren't really very primitive, but we introduce them here
			for convenience:
		</p><table width="100%" cellpadding="5" bgcolor="#F5DCB3" border="1" class="productionset" summary="EBNF"><tr><td><table border="0" width="99%" cellpadding="0" bgcolor="#F5DCB3" class="productionset" summary="EBNF productions"><tr><td align="left" valign="top" width="3%">[10]</td><td align="right" valign="top" width="10%">
					class_name
				</td><td valign="top" width="5%" align="center"><code>::=</code></td><td valign="top" width="52%">
					string
				</td><td align="left" valign="top" width="30%"> </td></tr></table></td></tr></table><p>
			A class_name is a special case of a string: the name of a class as defined
			by the IDL.  The class may refer either to a database table or to a
			source_definition, which is a subquery.
		</p><table width="100%" cellpadding="5" bgcolor="#F5DCB3" border="1" class="productionset" summary="EBNF"><tr><td><table border="0" width="99%" cellpadding="0" bgcolor="#F5DCB3" class="productionset" summary="EBNF productions"><tr><td align="left" valign="top" width="3%">[11]</td><td align="right" valign="top" width="10%">
					field_name
				</td><td valign="top" width="5%" align="center"><code>::=</code></td><td valign="top" width="52%">
					string
				</td><td align="left" valign="top" width="30%"> </td></tr></table></td></tr></table><p>
			A field_name is another special case of a string: the name of a non-virtual
			field as defined by the IDL.  A field_name is also a column name for the
			table corresponding to the relevant class.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id1165795"></a>Query</h2></div></div></div><p>
			The following production applies not only to the main query but also to
			most subqueries.
		</p><table width="100%" cellpadding="5" bgcolor="#F5DCB3" border="1" class="productionset" summary="EBNF"><tr><td><table border="0" width="99%" cellpadding="0" bgcolor="#F5DCB3" class="productionset" summary="EBNF productions"><tr><td align="left" valign="top" width="3%">[12]</td><td align="right" valign="top" width="10%">
					query
				</td><td valign="top" width="5%" align="center"><code>::=</code></td><td valign="top" width="52%">
					'{'<br>
					'&#8221;from&#8221;'  ':'  from_list<br>
					[ ','  '&#8221;select&#8221;'    ':'  select_list ]<br>
					[ ','  '&#8221;where&#8221;'     ':'  where_condition ]<br>
					[ ','  '&#8221;having&#8221;'    ':'  where_condition ]<br>
					[ ','  '&#8221;order_by&#8221;'  ':'  order_by_list ]<br>
					[ ','  '&#8221;limit&#8221;'     ':'  integer ]<br>
					[ ','  '&#8221;offset&#8221;'    ':'  integer ]<br>
					[ ','  '&#8221;distinct&#8221;'  ':'  boolean ]<br>
					[ ','  '&#8221;no_i18n&#8221;'   ':'  boolean ]<br>
					'}'
				</td><td align="left" valign="top" width="30%"> </td></tr></table></td></tr></table><p>
			Except for the <code class="literal">&#8220;distinct&#8221;</code> and <code class="literal">&#8220;no_i18n&#8221;</code>
			entries, each name/value pair represents a major clause of the SELECT statement.
			The name/value pairs may appear in any order.
		</p><p>
			There is no name/value pair for the GROUP BY clause, because json_query
			generates it automatically according to information encoded elsewhere.
		</p><p>
			The <code class="literal">&#8220;distinct&#8221;</code> entry, if present and true, tells json_query
			that it may have to create a GROUP BY clause.  If not present, it defaults to false.
		</p><p>
			The <code class="literal">&#8220;no_i18n&#8221;</code> entry, if present and true, tells json_query to
			suppress internationalization.  If not present, it defaults to false.  (Note that
			<code class="literal">&#8220;no_i18n&#8221;</code> contains the digit one, not the letter ell.)
		</p><p>
			The values for <code class="literal">&#8220;limit&#8221;</code> and <code class="literal">&#8220;offset&#8221;</code>
			provide the arguments of the LIMIT and OFFSET clauses, respectively, of the
			SQL statement.  Each value should be non-negative, if present, or else the
			SQL won't work.
		</p></div></div></body></html>
