<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.5//EN"
	"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<article xmlns="http://docbook.org/ns/docbook">

	<artheader>
		<title>Grammar of JSON Queries</title>
		<author>
			<firstname>Scott</firstname>
			<surname>McKellar</surname>
		</author>
	</artheader>

	<sect1><title>Introduction</title>
		<para>
			The format of this grammar approximates Extended Backus-Naur notation.  However it
			is intended as input to human beings, not to parser generators such as Lex or
			Yacc.  Do not expect formal rigor.  Sometimes narrative text will explain things
			that are clumsy to express in formal notation.  More often, the text will restate
			or summarize the formal productions.
		</para>
		<para>
			Conventions:
		</para>
		<orderedlist>
			<listitem>
				The grammar is a series of productions.
			</listitem>
			<listitem>
				A production consists of a name, followed by "::=", followed by a
				definition for the name.  The name identifies a grammatical construct that can
				appear on the right side of another production.
			</listitem>
			<listitem>
				Literals (including punctuation) are enclosed in single quotes, or in double
				quotes if case is not significant.
			</listitem>
			<listitem>
				A single quotation mark within a literal is escaped with a preceding backslash.
			</listitem>
			<listitem>
				If a construct can be defined more than one way, then the alternatives may appear
				in separate productions; or, they may appear in the same production, separated by
				pipe symbols.  The choice between these representations is of only cosmetic
				significance.
			</listitem>
			<listitem>
				A construct enclosed within square brackets is optional.
			</listitem>
			<listitem>
				A construct enclosed within curly braces may be repeated zero or more times.
			</listitem>
			<listitem>
				JSON allows arbitrary white space between tokens.  To avoid ugly clutter, this
				grammar ignores the optional white space.
			</listitem>
			<listitem>
				In many cases a production defines a JSON object, i.e. a list of name-value pairs,
				separated by commas.  Since the order of these name/value pairs is not significant,
				the grammar will not try to show all the possible sequences.  In general it will
				present the required pairs first, if any, followed by any optional elements.
			</listitem>
		</orderedlist>

		<para>
			Since both EBNF and JSON use curly braces and square brackets, pay close attention to
			whether these characters are in single quotes.  If they're in single quotes, they are
			literal elements of the JSON notation.  Otherwise they are elements of the EBNF notation.
		</para>
	</sect1>

	<sect1><title>Primitives</title>
		<para>
			We'll start by defining some primitives, to get them out of the way.  They're
			mostly just what you would expect.
		</para>

		<productionset>
			<production>
				<lhs>
					string
				</lhs>
				<rhs>
					'”' chars '”'
				</rhs>
			</production>

			<production>
				<lhs>
					chars
				</lhs>
				<rhs>
					any valid sequence of UTF-8 characters, with certain special characters
					escaped according to JSON rules
				</rhs>
			</production>

			<production>
				<lhs>
					integer_literal
				</lhs>
				<rhs>
					[ sign ] digit { digit }
				</rhs>
			</production>

			<production>
				<lhs>
					sign
				</lhs>
				<rhs>
					'+' | '-'
				</rhs>
			</production>

			<production>
				<lhs>
					digit
				</lhs>
				digit =  '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
				<rhs>
				</rhs>
			</production>

			<production>
				<lhs>
					integer_string
				</lhs>
				<rhs>
					'”'  integer_literal  '”'
				</rhs>
			</production>

			<production>
				<lhs>
					integer
				</lhs>
				<rhs>
					integer_literal  |  integer_string
				</rhs>
			</production>

			<production>
				<lhs>
					number
				</lhs>
				<rhs>
					any valid character sequence that is numeric according to JSON rules
				</rhs>
			</production>

		</productionset>

		<para>
			When json_query requires an integral value, it will usually accept a quoted string and
			convert it to an integer by brute force – to zero if necessary.  Likewise it may
			truncate a floating point number to an integral value.  Scientific notation will be
			accepted but may not give the intended results.
		</para>

		<productionset>

			<production>
				<lhs>
					boolean
				</lhs>
				<rhs>
					'true'  |  'false'  |  string  |  number
				</rhs>
			</production>

		</productionset>

		<para>
			The preferred way to encode a boolean is with the JSON reserved word true or false,
			in lower case without quotation marks.  The string “<literal>true</literal>”, in
			upper, lower, or mixed case, is another way to encode true.  Any other string
			evaluates to false.
		</para>
		<para>
			As an accommodation to perl, numbers may be used as booleans.  A numeric value of 1
			means true, and any other numeric value means false.
		</para>
		<para>
			Any other valid JSON value, such as an array, will be accepted as a boolean but interpreted
			as false.
		</para>
		<para>
			The last couple of primitives aren't really very primitive, but we introduce them here
			for convenience:
		</para>

		<productionset>

			<production>
				<lhs>
					class_name
				</lhs>
				<rhs>
					string
				</rhs>
			</production>

		</productionset>

		<para>
			A class_name is a special case of a string: the name of a class as defined
			by the IDL.  The class may refer either to a database table or to a
			source_definition, which is a subquery.
		</para>

		<productionset>

			<production>
				<lhs>
					field_name
				</lhs>
				<rhs>
					string
				</rhs>
			</production>

		</productionset>

		<para>
			A field_name is another special case of a string: the name of a non-virtual
			field as defined by the IDL.  A field_name is also a column name for the
			table corresponding to the relevant class.
		</para>

	</sect1>

	<sect1><title>Query</title>

		<para>
			The following production applies not only to the main query but also to
			most subqueries.
		</para>

		<productionset>

			<production>
				<lhs>
					query
				</lhs>
				<rhs>
					'{'<sbr/>
					'”from”'  ':'  from_list<sbr/>
					[ ','  '”select”'    ':'  select_list ]<sbr/>
					[ ','  '”where”'     ':'  where_condition ]<sbr/>
					[ ','  '”having”'    ':'  where_condition ]<sbr/>
					[ ','  '”order_by”'  ':'  order_by_list ]<sbr/>
					[ ','  '”limit”'     ':'  integer ]<sbr/>
					[ ','  '”offset”'    ':'  integer ]<sbr/>
					[ ','  '”distinct”'  ':'  boolean ]<sbr/>
					[ ','  '”no_i18n”'   ':'  boolean ]<sbr/>
					'}'
				</rhs>
			</production>

		</productionset>

		<para>
			Except for the <literal>“distinct”</literal> and <literal>“no_i18n”</literal>
			entries, each name/value pair represents a major clause of the SELECT statement.
			The name/value pairs may appear in any order.
		</para>
		<para>
			There is no name/value pair for the GROUP BY clause, because json_query
			generates it automatically according to information encoded elsewhere.
		</para>
		<para>
			The <literal>“distinct”</literal> entry, if present and true, tells json_query
			that it may have to create a GROUP BY clause.  If not present, it defaults to false.
		</para>
		<para>
			The <literal>“no_i18n”</literal> entry, if present and true, tells json_query to
			suppress internationalization.  If not present, it defaults to false.  (Note that
			<literal>“no_i18n”</literal> contains the digit one, not the letter ell.)
		</para>
		<para>
			The values for <literal>“limit”</literal> and <literal>“offset”</literal>
			provide the arguments of the LIMIT and OFFSET clauses, respectively, of the
			SQL statement.  Each value should be non-negative, if present, or else the
			SQL won't work.
		</para>

	</sect1>

	<sect1><title>FROM Clause</title>
		<para>
			The object identified by <literal>“from”</literal> encodes the FROM clause of
			the SQL.  The associated value may be a string, an array, or a JSON object.
		</para>

		<productionset>

			<production>
				<lhs>
					from_list
				</lhs>
				<rhs>
					class_name
				</rhs>
			</production>

		</productionset>

		<para>
			If <literal>from_list</literal> is a <literal>class_name</literal>, the
			json_query inserts the corresponding table name or subquery into the FROM
			clause, using the <literal>class_name</literal> as an alias for the table
			or subquery.  The class must be defined as non-virtual in the IDL.
		</para>

		<productionset>

			<production>
				<lhs>
					from_list
				</lhs>
				<rhs>
					'['  string  {  ','  parameter  }  ']'
				</rhs>
			</production>

			<production>
				<lhs>
					parameter
				</lhs>
				<rhs>
					string  |  number  |  'null'
				</rhs>
			</production>

		</productionset>

		<para>
			If from_list is a JSON array, then it represents a table-like function from
			which the SQL statement will select rows, using a SELECT clause consisting
			of “SELECT *” (regardless of the select_list supplied by the method parameter).
		</para>
		<para>
			The first entry in the array is the name of the function.  It must be a string
			naming a stored function.  Each subsequent entry is a function parameter.  If
			it is a string or a number, json_query will insert it into a comma-separated
			parameter list, enclosed in quotes, with any special characters escaped as needed.
			If it is the JSON reserved word <literal>null</literal>, json_query will insert
			it into the parameter list as a null value.
		</para>
		<para>
			If <literal>from_list</literal> is a JSON object, it must contain exactly one entry.
			The key of this entry must be the name of a non-virtual class defined in the IDL.
			This class will be the top-level class of the FROM clause, the only one named
			outside of a JOIN clause.
		</para>

		<productionset>

			<production>
				<lhs>
					from_list
				</lhs>
				<rhs>
					'{' class_name ':' join_list '}'
				</rhs>
			</production>

			<production>
				<lhs>
					join_list
				</lhs>
				<rhs>
					class_name
				</rhs>
			</production>

			<production>
				<lhs>
					join_list
				</lhs>
				<rhs>
					'{' join_def { ',' join_def } '}'
				</rhs>
			</production>

		</productionset>

		<para>
			If the associated data is a <literal>class_name</literal>, json_query will
			construct an INNER JOIN clause joining the class to the top-level clause,
			using the columns specified by the IDL for such a join.
		</para>
		<para>
			Otherwise, the associated data must be a JSON object with one or more entries,
			each entry defining a join:
		</para>
		
		<productionset>

			<production>
				<lhs>
					join_def
				</lhs>
				<rhs>
					class_name  ':'<sbr/>
					'{'<sbr/>
					[  '”type”'      ':'  string      ]<sbr/>
					[  '”field”'     ':'  field_name  ]<sbr/>
					[  '”fkey”'      ':'  field_name  ]<sbr/>
					[  '”filter”'    ':'  where_condition  ]<sbr/>
					[  '”filter_op”' ':'  string      ]<sbr/>
					[  '”join”'      ':'  join_list   ]<sbr/>
					'}'

				</rhs>
			</production>
			
		</productionset>

		<para>
			The data portion of the <literal>“join_type”</literal> entry tells json_query
			whether to use a left join, right join, full join, or inner join.  The values
			<literal>“left”</literal>, <literal>“right”</literal>, and <literal>“full”</literal>,
			in upper, lower, or mixed case, have the obvious meanings.  If the
			<literal>“join_type”</literal> entry has any other value, or is not present,
			json_query constructs an inner join.
		</para>
		<para>
			The <literal>“field”</literal> and <literal>“fkey”</literal> attributes specify the
			columns to be equated in the join condition.  The <literal>“field”</literal> 
			attribute refers to the column in the joined table, i.e. the one named by the
			<literal>join_def</literal>.  The <literal>“fkey”</literal> attribute refers to the
			corresponding column in the other table, i.e. the one named outside the
			<literal>join_def</literal> – either the top-level table or a table named by some
			other <literal>join_def</literal>.
		</para>
		<para>
			It may be tempting to suppose that <literal>“fkey”</literal> stands for “foreign key”,
			and therefore refers to a column in the child table that points to the key of a
			parent table.  Resist the temptation; the labels are arbitrary.  The json_query
			method doesn't care which table is the parent and which is the child.
		</para>
		<para>
			These relationships are best explained with an example.  The following <literal>from_list</literal>:
		</para>

		<informalexample><programlisting language="JSON">
	{
	    "aou": {
	        "asv": {
	        "type" : "left",
	        "fkey" : "id",
	        "field" : "owner"
	        }
	    }
	}
		</programlisting></informalexample>

		<para>
			...turns into the following FROM clause:
		</para>

		<informalexample><programlisting language="SQL">
	FROM
	    actor.org_unit AS "aou"
	        LEFT JOIN action.survey AS "asv"
	            ON ( "asv".owner = "aou".id )
		</programlisting></informalexample>

		<para>
			Note in this example that <literal>“fkey”</literal> refers to a column of the
			class <literal>“aou”</literal>, and <literal>“field”</literal> refers to a
			column of the class <literal>“asv”</literal>.
		</para>
		<para>
			If you specify only one of the two columns, json_query will try to identify the
			other one from the IDL. However, if you specify only the column from the parent
			table, this attempt will probably fail.
		</para>
		<para>
			If you specify both columns, json_query will use the column names you specify,
			without verifying them with a lookup in the IDL.  By this means you can perform
			a join using a linkage that the IDL doesn't define.  Of course, if the columns
			don't exist in the database, the query will fail when json_query tries to execute it.
		</para>
		<para>
			Using the columns specified, either explicitly or implicitly, the json_query
			method constructs a join condition.  With raw SQL it is possible (though
			rarely useful) to join two tables by an inequality.  However the json_query
			method always uses a simple equality condition.
		</para>
		<para>
			Using a <literal>“filter”</literal> entry in the join_def, you can apply one
			or more additional conditions to the JOIN clause, typically to restrict the
			join to certain rows of the joined table.  The data associated with the
			<literal>“filter”</literal> key is the same sort of
			<literal>where_condition</literal> that you use for a WHERE clause
			(discussed below).
		</para>
		<para>
			If the string associated with the <literal>“filter_op”</literal> entry is
			<literal>“OR”</literal> in upper, lower, or mixed case, then the json_query
			method uses OR to connect the standard join condition to any additional
			conditions supplied by a <literal>“filter”</literal> entry.
		</para>
		<para>
			(Note that if the <literal>where_condition</literal> supplies multiple
			conditions, they will be connected by AND.  You will probably want to move
			them down a layer – enclose them in parentheses, in effect – to avoid a
			confusing mixture of ANDs and ORs.)
		</para>
		<para>
			If the <literal>“filter_op”</literal> entry carries any other value, or if
			it is absent, then the json_query method uses AND.  In the absence of a
			<literal>“filter”</literal> entry, <literal>“filter_op”</literal> has no effect.
		</para>
		<para>
			A <literal>“join”</literal> entry in a <literal>join_def</literal> specifies
			another layer of join.  The class named in the subjoin is joined to the class
			named by the <literal>join_def</literal> to which it is subordinate.  By this
			means you can encode multiple joins in a hierarchy.
		</para>
	</sect1>

	<sect1><title>SELECT Clause</title>
		<para>
			If a query does not contain an entry for <literal>“select”</literal>, json_query
			will construct a default SELECT clause.  The default includes every non-virtual
			field from the top-level class of the FROM clause, as defined by the IDL.  The
			result is similar to SELECT *, except:
		</para>

		<itemizedlist>
			<listitem>
				The default includes only the fields defined in the IDL.
			</listitem>
			<listitem>
				The columns will appear in the same order in which they appear in the IDL,
				regardless of the order in which the database defines them.
			</listitem>
		</itemizedlist>

		<para>
			There are other ways to specify a default SELECT list, as shown below.
		</para>
		<para>
			If a <literal>“select”</literal> entry is present, the associated value must
			be a JSON object, keyed on class names:
		</para>

		<productionset>

			<production>
				<lhs>
					select_list
				</lhs>
				<rhs>
					'{' class_name ':' field_list { ',' class_name ':' field_list } '}'
				</rhs>
			</production>

		</productionset>

		<para>
			The <literal>class_name</literal> must identify either the top-level class or
			a class belonging to one of the joins.  Otherwise json_query will silently
			ignore the <literal>select_list</literal>.
		</para>

		<productionset>

			<production>
				<lhs>
					field_list
				</lhs>
				<rhs>
					'null'  |  '”*”'
				</rhs>
			</production>

		</productionset>

		<para>
			If a field_list is either the JSON reserved word <literal>null</literal>
			(in lower case) or an asterisk in double quotes, json_query constructs a
			default SELECT list – provided that the class is the top-level class of the
			query.  If the class belongs to a join somewhere, json_query ignores the
			<literal>field_list</literal>.
		</para>
		<para>
			More commonly, the <literal>field_list</literal> is a JSON array of zero or
			more field specifications:
		</para>

		<productionset>

			<production>
				<lhs>
					field_list
				</lhs>
				<rhs>
					'['  [  field_spec  {  ','  field_spec  }  ]  ']'
				</rhs>
			</production>

		</productionset>

		<para>
			If the array is empty, json_query will construct a default SELECT list for
			the class – again, provided that the class is the top-level class in the query.
		</para>
		<para>
			In the simplest case, a field specification may name a non-virtual field
			defined in the IDL:
		</para>

		<productionset>

			<production>
				<lhs>
					field_spec
				</lhs>
				<rhs>
					field_name
				</rhs>
			</production>

		</productionset>

		<para>
			In some cases json_query constructs a call to the
			<literal>oils_i18n_xlate</literal> function to internationalize the value of the
			selected column.  Specifically, it does so if all the following are true:
		</para>

		<itemizedlist>
			<listitem>
				the settings file defines a locale;
			</listitem>
			<listitem>
				in the field definition for the field in the IDL, the tag
				<literal>“il8n”</literal> is present and true;
			</listitem>
			<listitem>
				the query does <emphasis>not</emphasis> include the 
				<literal>“no_il8n”</literal> tag (or includes it with a value of false).
			</listitem>
		</itemizedlist>

		<para>
			A field specification may be a JSON object:
		</para>

		<productionset>

			<production>
				<lhs>
					field_spec
				</lhs>
				<rhs>
					'{'<sbr/>
					'”column”'  ':'  <sbr/>
					[ ',' '”alias”'  ':'  string  ]<sbr/>
					[ ',' '”aggregate”'  ':'  boolean  ]<sbr/>
					[ ',' transform_spec  ]<sbr/>
					'}'

				</rhs>
			</production>

		</productionset>

		<para>
			The <literal>“column”</literal> entry provides the column name, which must
			be defined as non-virtual in the IDL.
		</para>
		<para>
			The <literal>“alias”</literal> entry provides a column alias.  If no alias
			is specified, json_query uses the column name as its own alias.
		</para>
		<para>
			The <literal>“aggregate”</literal> entry has no effect on the SELECT clause
			itself.  Rather, it affects the construction of a GROUP BY class.  If there
			is an <literal>“aggregate”</literal> entry for any field, then json_query builds
			a GROUP BY clause listing every column that is <emphasis>not</emphasis> tagged
			for aggregation (or that carries an <literal>“aggregate”</literal> entry with
			a value of false).  If <emphasis>all</emphasis> columns are tagged for
			aggregation, then json_query omits the GROUP BY clause.
		</para>

		<productionset>

			<production>
				<lhs>
					transform_spec
				</lhs>
				<rhs>
					'”transform”'  ':'  string  ]<sbr/>
					[ ',' '”result_field”  ':'  string  ]<sbr/>
					[ ',' '”params”  ':' param_list  ]
				</rhs>
			</production>

		</productionset>

		<para>
			When a <literal>transform_spec</literal> is present, json_query selects the
			return value of a function instead of selecting the column directly.  The entry
			for <literal>“transform”</literal> provides the name of the function, and the
			column name (as specified by the <literal>“column”</literal> tag), qualified by
			the class name, is the argument to the function.  For example, you might use such
			a function to format a date or time, or otherwise transform a column value.
			You might also use an aggregate function such as SUM, COUNT, or MAX (possibly
			together with the <literal>“aggregate”</literal> tag).
		</para>
		<para>
			The <literal>“result_field”</literal> entry, when present, specifies a subcolumn
			of the function's return value.  The resulting SQL encloses the function call
			in parentheses, and follows it with a period and the subcolumn name.
		</para>
		<para>
			The <literal>“params”</literal> entry, if present, provides a possibly empty
			array of additional parameter values, either strings, numbers, or nulls:
		</para>

		<productionset>

			<production>
				<lhs>
					param_list
				</lhs>
				<rhs>
					'['  [  parameter  {  ','  parameter  }  ]  ']'
				</rhs>
			</production>

		</productionset>

		<para>
			Such parameter values are enclosed in single quotes, with any special characters
			escaped as needed, and inserted after the column name as additional parameters
			to the function.  You might, for example, use an additional parameter to provide
			a format string for a reformatting function.
		</para>
	</sect1>

	<sect1><title>WHERE Clause</title>
	</sect1>

	<sect1><title>ORDER BY Clause</title>
	</sect1>

</article>
